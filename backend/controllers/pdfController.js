import puppeteer from "puppeteer";

let browserInstance = null;
let browserLaunchPromise = null;

const getBrowser = async () => {
  if (browserInstance && browserInstance.connected) {
    return browserInstance;
  }

  if (browserLaunchPromise) {
    return browserLaunchPromise;
  }

  browserLaunchPromise = puppeteer.launch({
    headless: "new",
    args: [
      "--no-sandbox",
      "--disable-setuid-sandbox",
      "--disable-dev-shm-usage",
      "--disable-gpu",
      "--disable-web-security",
      "--disable-features=IsolateOrigins,site-per-process"
    ]
  });

  try {
    browserInstance = await browserLaunchPromise;
    
    browserInstance.on('disconnected', () => {
      console.log("âš ï¸ Browser disconnected");
      browserInstance = null;
      browserLaunchPromise = null;
    });

    return browserInstance;
  } finally {
    browserLaunchPromise = null;
  }
};

export const generatePDF = async (req, res) => {
  console.log("ðŸ”¥ PDF GENERATION STARTED ðŸ”¥");

  let page;
  let pageCreated = false;

  try {
    const { htmlContent, filename = "BRisk_Report.pdf" } = req.body;

    if (!htmlContent) {
      return res.status(400).json({ error: "HTML content is required" });
    }

    console.log("ðŸ“Š HTML Content size:", htmlContent.length, "characters");

    const browser = await getBrowser();
    
    page = await browser.newPage();
    pageCreated = true;
    
    console.log("ðŸ“„ Page created");

    // Set no timeout
    await page.setDefaultTimeout(0);
    await page.setDefaultNavigationTimeout(0);

    await page.setViewport({
      width: 1200,
      height: 1600,
      deviceScaleFactor: 1
    });

    console.log("ðŸ”„ Setting content...");

    // FIX: Use setContent directly - it's more reliable for large HTML
    await page.setContent(htmlContent, {
      waitUntil: "networkidle0",
      timeout: 60000
    });

    console.log("âœ… Content loaded");

    // Wait for any charts/images to render
    await page.evaluate(() => {
      return new Promise(resolve => setTimeout(resolve, 3000));
    });

    console.log("ðŸ“¸ Generating PDF...");

    const pdfBuffer = await page.pdf({
       format: "A4",
    
      printBackground: true,
      displayHeaderFooter: true,

     headerTemplate: `
  <div style="
    width:100%;
    font-size:10px;
    padding:6px 40px;
    box-sizing:border-box;
    color:#333;
    border-bottom:1px solid #e5e7eb;
    font-family:Arial, sans-serif;
  ">
    <span style="font-weight:600">
    <span style="color:#1d1ac9ff">STARTUP</span><span style="color: #FFFF00">VISORS</span>
    </span>
  </div>
`,

      footerTemplate: `
        <div style="
          width:100%;
          font-size:9px;
          padding:6px 40px;
          box-sizing:border-box;
          color:#666;
          border-top:1px solid #e5e7eb;
          font-family:Arial, sans-serif;
          display:flex;
          justify-content:space-between;
        ">
          <span>Generated by Startupvisors</span>
          <span>
            Page <span class="pageNumber"></span> of <span class="totalPages"></span>
          </span>
        </div>
      `,

      margin: {
        top: "30mm",
        bottom: "22mm",
        left: "8mm",
        right: "8mm"
      },

      timeout: 0
    });

    res.setHeader("Content-Type", "application/pdf");
    res.setHeader(
      "Content-Disposition",
      `attachment; filename="${filename}"`
    );

    res.end(pdfBuffer);
    console.log("âœ… PDF GENERATED SUCCESSFULLY");

  } catch (error) {
    console.error("âŒ PDF Error:", error.message);
    console.error("âŒ Stack:", error.stack);
    
    if (!res.headersSent) {
      res.status(500).json({ error: error.message });
    }

  } finally {
    if (pageCreated && page) {
      try {
        await page.close();
        console.log("ðŸ”’ Page closed");
      } catch (err) {
        console.error("Error closing page:", err.message);
      }
    }
  }
};

// Graceful shutdown
process.on('SIGINT', async () => {
  console.log("ðŸ›‘ Shutting down...");
  if (browserInstance) {
    await browserInstance.close();
  }
  process.exit(0);
});

process.on('SIGTERM', async () => {
  console.log("ðŸ›‘ Shutting down...");
  if (browserInstance) {
    await browserInstance.close();
  }
  process.exit(0);
});